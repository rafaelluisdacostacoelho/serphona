Act as a senior backend and cloud architect with strong experience in Go, Stripe, and high-availability payment systems.

I’m building a Go microservice called “Serphona Payments Service”. Its main goals are:

1. Integrate with Stripe (and later other gateways) to:
   - create and manage customers
   - create and manage subscriptions
   - charge one-time payments
   - handle refunds and cancellations
   - manage payment methods

2. Support two billing models:
   - Subscriptions (recurring, card-based, managed directly by Stripe)
   - Prepaid credits in a wallet (denominated in USD) that are consumed by usage-based services in my platform.

3. Act as the central authority for:
   - Tenant-level customer configuration (mapping internal tenant/client IDs to Stripe customers)
   - Wallet balances and wallet transactions
   - Subscription status for multiple products/features in the same tenant
   - Emitting domain events so that an IAM/roles service can grant or revoke user roles based on active subscriptions.

4. Use Stripe webhooks as the source of truth for payment status:
   - invoice events, subscription events, payment_intent events, refunds, etc.
   - enforce idempotency and safe retry handling.

5. Be multi-tenant from day one:
   - every entity should be scoped by tenant/client ID
   - support multiple subscriptions and multiple payment methods per tenant.

6. Emit events to a message broker (Kafka, RabbitMQ, or AWS SQS/SNS style) so that:
   - another service can grant/revoke roles for users when subscriptions are activated or cancelled
   - other services can react to wallet top-ups, low-balance warnings, and failed charges.

Please:

1. Propose a high-level architecture for this microservice:
   - main logical components
   - main bounded contexts (e.g., Billing, Subscriptions, Wallet, PaymentProviders, Webhooks, Events)
   - how these components interact

2. Suggest a clean architecture / hexagonal style organization in Go:
   - layers and packages (domain, application/usecases, adapters, infra)
   - interface boundaries (e.g. PaymentProviderPort, EventPublisherPort, WalletRepository, SubscriptionRepository, etc.)

3. Define the core domain concepts and aggregates:
   - Tenant/Client, User, Subscription, Plan, Product/Feature, Wallet, WalletTransaction, PaymentMethod, PaymentAttempt, WebhookEventLog
   - indicate which entities are aggregates and why

4. Describe the main workflows:
   - “Tenant subscribes to a plan and gets roles”
   - “Tenant cancels a subscription and roles are removed”
   - “Tenant tops up wallet with USD credits”
   - “Service consumes credits from wallet for usage”
   - “Stripe sends a webhook about invoice.paid or subscription updated”

5. Highlight where to enforce:
   - idempotency
   - concurrency control
   - audit logging
   - error handling and retries

6. Explain how to keep the design payment-provider-agnostic so I can later plug in other gateways besides Stripe.

Output:
- A clear textual architecture description.
- A Go module/package layout proposal.
- A list of domain aggregates and their responsibilities.
- A short sequence diagram description for each main workflow (textual is fine).
